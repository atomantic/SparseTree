# Release v0.4.16 - AI Discovery & SQLite Stability

Released: 2026-01-23

## Overview

This release adds AI-powered ancestor discovery, test coverage reporting UI, and critical SQLite stability fixes to prevent database lock contention during concurrent operations.

## New Features

### AI Discovery & Test Coverage (v0.4.0)
- Added AI discovery feature for finding notable ancestors
- Test coverage reports UI for viewing test status

### SQLite Concurrency Fixes (v0.4.2)
- Fixed database lock contention causing app freezes during concurrent indexing and queries
- Added `busy_timeout = 30000` pragma - waits up to 30s for locks instead of failing immediately
- Added `wal_autocheckpoint = 1000` pragma - auto-checkpoints at ~4MB to prevent WAL bloat
- Added `checkpoint()` function to `sqliteService` for manual WAL checkpointing
- Added automatic WAL checkpoint after `finalizeDatabase()` in sqlite-writer

## Bug Fixes

### Fixed: App Freezing During Indexing (v0.4.2)
- **Symptom**: App became unresponsive when running path calculations while indexer was active
- **Cause**: WAL file grew to 1.2GB causing SQLite lock contention between reader and writer processes
- **Fix**: Added proper busy_timeout and wal_autocheckpoint pragmas, plus periodic checkpointing

### Fixed: Sparse Tree Page Freezing (v0.4.2)
- **Symptom**: App froze when navigating to favorites sparse-tree page on large databases
- **Cause**: Service was loading entire database (138k+ persons) into memory for BFS path finding
- **Fix**: Rewrote sparse-tree service to use SQLite queries for path finding with iterative BFS

### Fixed: Relationship Calculation Freezing (v0.4.2)
- **Symptom**: App froze when calculating relationship between two people
- **Cause**: Recursive CTEs explored exponentially many paths; fallback loaded entire database
- **Fix**: Rewrote path service to use iterative BFS with common ancestor algorithm (0.3s vs freeze)

## Technical Details

The SQLite WAL (Write-Ahead Log) mode provides excellent read concurrency, but can cause issues when:
1. The WAL file grows very large (>100MB)
2. Multiple processes access the database simultaneously
3. No busy_timeout is set (causing immediate failures instead of retries)

The fixes ensure:
- Readers wait for writers instead of failing immediately
- WAL is regularly checkpointed to prevent unbounded growth
- Large batch operations trigger explicit checkpoints

## Full Changelog

**Full Diff**: https://github.com/atomantic/SparseTree/compare/v0.3.21...v0.4.2
